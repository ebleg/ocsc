function [x_new] = state_transition2(x, u, par)
    % x = [alpha_arr_k+m ... [alpha_arr_k+1 q_udo1 q_udo2 q_udo3];
    % u = [alpha_enter, C_ud, g_udo, C_udo1, C_udo2, C_udo3]
    
    N = numel(x);
    
    % Compute N_cars, tau and gamma
    N_cars_old = total_cars(x, par);
    tau = floor(((u(2) - N_cars_old)*par.l_veh)/par.N_lane/par.v_free/par.c); % Eq 7
    gamma = rem((u(2) - N_cars_old)*par.l_veh/par.N_lane/par.v_free, par.c); % Eq 8
    
    % Construct vectors for the three queues
    queue = x((end-2):end);
    queue_new = zeros(size(queue));

    M = N - 3; % Maximum number of delayed states
    
    if M ~= 0 % Safety check; time delays are possible
        % Vectors for the cars entering
        enter = x(1:M);
        enter_new = [u(1); enter(1:end-1)]; % Newly arrived cars at the front
        % i.e. enter_new [arr_k, arr_k-1, arr_k-2, ...], zero delay means
        % the first entry

        % Get the cars arriving to the queue (Eq 6)
        arriving_total = (par.c - gamma)/par.c*enter_new(tau+1) ... % tau + 1 because for zero delay we want the first entry
                         + gamma/par.c*enter(tau+2);        
    end
    
    arriving = arriving_total*par.beta; % Vector of arriving cars per queue
    
    % Find the number of cars leaving per queue
    leaving = min([par.mu.*[u(3) u(3) 0]'/par.c, ...
                   queue/par.c + arriving, ...
                   u((end-2):end)/par.c], [], 2);
               
    queue_
    
    
end

